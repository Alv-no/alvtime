use crate::actions::utils::{generate_events_from_server_entries, round_duration_to_quarter_hour};
use crate::events::Event;
use crate::external_models::TaskDto;
use crate::store::EventStore;
use crate::{alvtime, external_models, models, projector};
use chrono::{Datelike, Local, NaiveDate};
use inquire::Select;
use std::collections::{HashMap, HashSet};

pub fn handle_sync(
    client: &alvtime::AlvtimeClient,
    tasks: &mut Vec<models::Task>,
    history: &mut Vec<Event>,
    event_store: &EventStore,
    external_tasks: &mut Vec<TaskDto>,
) -> String {
    let current_year = Local::now().year();
    println!("Fetching time entries for {}...", current_year);

    let mut entries = Vec::new();
    use std::io::Write;

    for month in 1..=12 {
        let start_date = NaiveDate::from_ymd_opt(current_year, month, 1).unwrap();
        let next_month_start = if month == 12 {
            NaiveDate::from_ymd_opt(current_year + 1, 1, 1).unwrap()
        } else {
            NaiveDate::from_ymd_opt(current_year, month + 1, 1).unwrap()
        };
        let end_date = next_month_start.pred_opt().unwrap();

        print!(".");
        std::io::stdout().flush().ok();

        match client.list_time_entries(start_date, end_date) {
            Ok(mut e) => entries.append(&mut e),
            Err(e) => return format!("\nFailed to fetch entries: {}", e),
        };
    }
    println!(" Done.");

    // 1. Group server entries by Date
    let mut entries_by_date: HashMap<NaiveDate, Vec<&external_models::TimeEntryDto>> =
        HashMap::new();

    let known_ids: HashSet<i32> = external_tasks.iter().map(|t| t.id).collect();
    let mut unknown_found = false;

    for entry in &entries {
        if !known_ids.contains(&entry.task_id) {
            unknown_found = true;
        }
        if let Ok(date) = NaiveDate::parse_from_str(&entry.date, "%Y-%m-%d") {
            entries_by_date.entry(date).or_default().push(entry);
        }
    }

    if unknown_found {
        println!("Encountered tasks not in cache. Refreshing task list...");
        match client.list_tasks() {
            Ok(t) => {
                event_store.save_tasks(&t);
                *external_tasks = t;
            }
            Err(e) => eprintln!("Failed to refresh tasks: {}", e),
        }
    }

    // 2. Identify which dates already have LOCAL events (not generated by sync)
    let local_dates: HashSet<NaiveDate> = event_store.get_unsynced_dates();
    let mut synced_days = 0;

    // 3. Handle Local Changes (Sync Only)
    for date in &local_dates {
        let server_entries = entries_by_date.get(date);
        let has_server_entries = server_entries.map(|e| !e.is_empty()).unwrap_or(false);

        let day_tasks: Vec<&models::Task> = tasks
            .iter()
            .filter(|t| t.start_time.date_naive() == *date && !t.is_break)
            .collect();

        if day_tasks.is_empty() && !has_server_entries {
            continue;
        }

        if has_server_entries {
            let server_entries_list = server_entries.unwrap();

            // Check if content is effectively the same (Task IDs, durations, and comments match)
            let mut server_breakdown: HashMap<i32, (f64, Option<String>)> = HashMap::new();
            for e in server_entries_list {
                let entry = server_breakdown.entry(e.task_id).or_insert((0.0, None));
                entry.0 += e.value;
                // Keep the comment (assume all entries for same task have same comment)
                if entry.1.is_none() {
                    entry.1 = e.comment.clone();
                }
            }

            let mut local_breakdown: HashMap<i32, (f64, Option<String>)> = HashMap::new();
            let mut local_sums: HashMap<i32, i64> = HashMap::new();
            let mut local_comments: HashMap<i32, Option<String>> = HashMap::new();

            for t in &day_tasks {
                *local_sums.entry(t.id).or_default() += t.duration().num_minutes();
                local_comments.entry(t.id).or_insert_with(|| t.comment.clone());
            }

            for (tid, mins) in local_sums {
                let comment = local_comments.get(&tid).and_then(|c| c.clone());
                local_breakdown.insert(tid, (round_duration_to_quarter_hour(mins), comment));
            }

            let mut is_match = server_breakdown.len() == local_breakdown.len();
            if is_match {
                for (t_id, (s_hours, s_comment)) in &server_breakdown {
                    if let Some((l_hours, l_comment)) = local_breakdown.get(t_id) {
                        // Allow 0.02h (approx 1 min) difference for rounding
                        if (s_hours - l_hours).abs() > 0.02 {
                            is_match = false;
                            break;
                        }
                        // Check if comments match
                        if s_comment != l_comment {
                            is_match = false;
                            break;
                        }
                    } else {
                        is_match = false;
                        break;
                    }
                }
            }

            if is_match {
                // Auto-sync: Replace local manual entries with server generated ones
                // because they represent the same data.
                let all_day_tasks: Vec<&models::Task> = tasks
                    .iter()
                    .filter(|t| t.start_time.date_naive() == *date)
                    .collect();

                let mut new_events = Vec::new();
                for task in all_day_tasks {
                    new_events.extend_from_slice(task.to_events().as_slice())
                }

                event_store.persist_synced_batch(&new_events);
                history.extend_from_slice(&new_events);

                synced_days += 1;
                println!("Auto-synced {}: Local matched Server.", date);
                continue;
            }

            let server_hours: f64 = server_entries_list.iter().map(|e| e.value).sum();
            let local_hours: f64 = local_breakdown.values().map(|(h, _)| h).sum();

            let msg = format!(
                "Conflict on {}: Local {:.1}h vs Server {:.1}h. What do you want to do?",
                date, local_hours, server_hours
            );

            let options = vec!["Discard Local (Sync from Server)", "Skip Day (Keep Local)"];

            match Select::new(&msg, options).prompt() {
                Ok(choice) => match choice {
                    "Discard Local (Sync from Server)" => {
                        // Generate events from server data
                        let new_events = generate_events_from_server_entries(
                            *date,
                            server_entries_list,
                            external_tasks,
                        );
                        event_store.persist_synced_batch(&new_events);
                        history.extend_from_slice(&new_events);
                        synced_days += 1;
                    }
                    _ => {
                        // Skip
                    }
                },
                Err(_) => {}
            }
        }
    }

    let mut added_count = 0;
    let mut dates_to_sync = Vec::new();
    let mut all_new_events = Vec::new();

    // 4. Process new dates
    for (date, day_entries) in entries_by_date {
        if local_dates.contains(&date) {
            continue; // Skip syncing for days that already have local data (or were handled above)
        }

        let total_hours: f64 = day_entries.iter().map(|e| e.value).sum();
        if total_hours == 0.0 {
            continue;
        }

        dates_to_sync.push(date);
        let mut events = generate_events_from_server_entries(date, &day_entries, external_tasks);
        all_new_events.append(&mut events);
    }

    if !dates_to_sync.is_empty() {
        // Explicitly delete existing events for these days from the store
        event_store.delete_events_for_days(&dates_to_sync);

        // If the date being synced is the current day (today), clear the in-memory history
        // so we can rebuild it with the fresh events from the server.
        let today = Local::now().date_naive();
        if dates_to_sync.contains(&today) {
            history.clear();
        }

        event_store.persist_synced_batch(&all_new_events);

        for evt in &all_new_events {
            // Only push to history if it is for the current day
            if evt.date() == today {
                history.push(evt.clone());
            }
        }
        added_count = dates_to_sync.len();
    }

    if added_count > 0 || synced_days > 0 {
        // Restore state after bulk insert (re-projects history into tasks)
        *tasks = projector::restore_state(history);
        format!(
            "Synced. Pulled {} days, Overwrote Local {} days.",
            added_count, synced_days
        )
    } else {
        "No incoming changes.".to_string()
    }
}